/**
* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
* 
* Copyright (c) 2016 LIBSCAPI (http://crypto.biu.ac.il/SCAPI)
* This file is part of the SCAPI project.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
* 
* Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"),
* to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, 
* and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
* 
* The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
* 
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
* FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
* 
* We request that any publication and/or code referring to and/or based on SCAPI contain an appropriate citation to SCAPI, including a reference to
* http://crypto.biu.ac.il/SCAPI.
* 
* Libscapi uses several open source libraries. Please see these projects for any further licensing issues.
* For more information , See https://github.com/cryptobiu/libscapi/blob/master/LICENSE.MD
*
* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
* 
*/

#pragma once

#include "Config.h"
#include "TedKrovetzAesNiWrapperC.h"
#include "../infra/Common.hpp"
#include <tuple>
#include <vector>


struct GarbledGate;

/*
 * GarbledBooleanCircuit is a general abstract class for garbled circuits. 
 * All garbled circuits have four main operations: 
 * 1. The garble function that creates the garbled table
 * 2. The compute function that computes a result on a garbled circuit on the input which is the keys that were chosen for each input wire. 
 * 3. The verify method is used in the case of a malicious adversary to verify that the garbled circuit 
 * created is an honest garbling of the agreed upon non garbled circuit. 
 * 4. The translate method that translates the garbled output which usually is generated by the compute() function into meaningful output (a 0/1 result, rather 
 * than the keys outputed by compute)
 * 
 *	author: Cryptography and Computer Security Research Group Department of Computer Science Bar-Ilan University (Meital Levy)
 * 
 */
class GarbledBooleanCircuit
{
public:
	
	/*
	* This method generates calls the undelying implementation of garble in the derived classes using the seed.
	* It generates inputs outputs and tranlation table and passes that to the underlying garble to fill.
	* The keys for each wire are not saved. The input keys and the output keys that were created are returned to the
	* user. The user usually saves these value for later use. The user also gets the generated translation table, which is
	* the signal bits of the output wires.
	*
	* return values in the tuple:
	* block * : A block array that will be filled with both input keys generated in garble.
	* block * : An empty block array that will be filled with both output keys generated in garble.
	* byte : An char array that will be filled with 0/1 signal bits that we chosen in random in this function.
	*/
	 std::tuple<block*, block*, std::vector<byte> > garble(block *seed = nullptr);


	/**
	 * This method computes the circuit for the given input singleWiresInputKeys. 
	 * It returns a the garbled values keys for the output wires. This output can be translated via the translate() method
	 * if the translation table is set.
	 */
	virtual void compute(block *singleWiresInputKeys,block * Output) = 0;

	/**
     * The verify method is used in the case of malicious adversaries.
     * For example, Alice can constructs n circuits and Bob can verify n-1 of them (of his choice) to confirm that they are indeed garbling of the 
     * agreed upon non garbled circuit. In order to verify, Alice has to give Bob both keys for each of the input wires.

     * bothInputKeys: An array containing both keys for each input wire. For each input wire , 
	 * the first garbled value is the 0 encoding, that is the 0 garbled value, and the second value is the 1 encoding.
     * returns:  true, if this GarbledBooleanCircuit is a garbling the given keys, false otherwise.
     */
	bool verify(block *bothInputKeys);

	/**
	 * This function does the last part of the verify function. It gets both keys of each output wire and checks that 
	 * their signal bits match the corresponding bit in the translation table.
	 * 
	 * The circuit verify is composed of both internalVerify function followed by this function.
	 * @param allOutputWireValues both keys of each output wire.
	 * @return {@code true} if the given keys match the translation table ,{@code false} if not.
	 */
	bool verifyTranslationTable(block * emptyBothWireOutputKeys);

	/**
     * This is a virtual function that is implemented in the derived classes due to many changes in each derived class.
	 * This function behaves exactly as the verify method except the last phase.
     * The verify function verifies that the translation table matches the resulted output garbled values, while this function does not, rather, 
	 * it returns the resulted output garbled values. 
	 *
     * bothWiresInputKeys : both keys for each input wire. This array must be filled with both input keys
	 * emptyBothWireOutputKeys :T his array will be filled with both output keys during the process of the function. It must be empty.
     * 
     * returns : true if this GarbledBooleanCircuit is a garbling the given keys, false otherwise.
     */
	virtual bool internalVerify(block *bothWiresInputKeys, block *emptyBothWireOutputKeys) = 0;
	

protected:

	bool isFreeXor;//A flag indicating if the user wants to use the optimization of FreeXor.
	
	bool isNonXorOutputsRequired;//A flag that indicates that the output wires randomized rather than have a common delta between the 0-wire and the 1-wire.

	int numberOfInputs;//The total number of inputs for all parties
	int numberOfOutputs;//Number of outputs
	int lastWireIndex;//The index of the last wire in the circuit. This determines the size of the wire array and thus should not be
				      //much higher than the actual number of wires
	int numberOfGates;//The number of gates in the circuit (excluding the -1 index of the fixed 1 gate that provides a wire that allways
					  //computes to the 1 garbled value.
	int numOfXorGates; //The number of XOR gates. This is used when the free xor optimization is used in order to use garbled table just 
					   //for the non-XOR gates.
	int numOfNotGates;//The number of NOT gates. This is used when the free xor optimization is used in order to use garbled table just 
					   //for the non-XOR gates.

	bool NOTgateOptimization;

	int numberOfParties;//The number parties participating in the protocol that uses the circuit.
	int* numOfInputsForEachParty;//An array that holds for each party the number of inputs it has in the circuit.

	std::vector<int> inputIndices;//The indices of the input wires.
	std::vector<int> outputIndices;//The indices of the output wires.
	
	block seed;//The seed is used to create the garbled value via AES. The seed is the key of the AES that generates random values.

	 /*
  	 * We store the garbled tables in a one dimensional array of GarbleTable. 
	 * GarbleTable is an array of blocks(128 bit variable), the garbled in the array corresponds to the gate 
  	 * Each table of each gate is a one dimensional array of bytes rather than an array of ciphertexts. 
  	 * This is for time/space efficiency reasons: If a single garbled table is an array of ciphertext that holds a byte array the space
  	 * stored by java is big. The main array holds references for each item (4 bytes). Each array in java has an overhead of 12 bytes. 
  	 * Thus the garbled table with ciphertexts has at least (12+4)*number of rows overhead.
  	 * If we store the array as one dimensional array we only have 12 bytes overhead for the entire table and thus this is the way we 
  	 * store the garbled tables. 
  	 */
	 block* garbledTables;

	
	 GarbledGate *garbledGates;//An array that holds the garbled gates. This is fiiled by the derived classes according to the derived class needs
	/*
	 * The translation table stores the signal bit for the output wires. Thus, it just tells you whether the wire coming out is a 
	 * 0 or 1 but does not reveal information about the 2 keys of the wire. This is good since it is possible that a circuit output 
	 * wire is also an input wire to a different gate, and thus if the translation table contained both keys 
	 * values of the output Wire, the constructing party could change the value of the wire when it is input into a gate, and 
	 * privacy and/or correctness will not be preserved. Therefore, we only reveal the signal bit, and the other
	 * possible value for the wire is not stored on the translation table.
	 */
	 std::vector<byte> translationTable;

	/*
	/two aes encryption schemes that will be used in all the derived classes
	/The seed is given by the user of the garbled circuit and the fixedKey is hardcoded
	*/
	
	AES_KEY aesSeedKey;//We use a pointer since new with 32 bit does not 16-align the variable by default


	//These values could have been defined locally in the functions that use them, however, if we define and allocate
	//these values in construction, the performance is better. Allocating the memory consumes negligible time, but using
	//values of these array without some initialization (in our case using memset) causes a lot of cache misses and thus 
	//performance decrease. We make sure to delete these values in the destructor.
	block* garbledWires;
	block* computedWires;

public:
	
	GarbledBooleanCircuit(void);
	virtual  ~GarbledBooleanCircuit(void);

	/**
	* Reads a file and fill the gates, number of parties, input indices, output indices and so on.
	* In addition initializes the member variables such as isFreeXor, isRowReduction and other variables that are set to nullptr.
	* It uses a fixed pre-defined fixed key and initializes the openSsl object accordingly.
	* It also allocates memory according to the circuit it creates, such as computedWires, garbledWires and so on. This
	* is done in the construction, rather than in the relevant function to reduce the cache misses.
	*/
	virtual void createCircuit(const char* fileName, bool isFreeXor, bool isNonXorOutputsRequired=false);

	/**
	* This method read text file and creates an object of GarbledBooleanCircuit according to the file.
	* This includes creating the gates and other information about the parties involved. It also counts the number of XORGATES 
	* in order to allocate garbled tables only for the non-XOR gates.
	* 
	*/
	void readCircuitFromFile(const char* fileName);

	/**
	* This method gets as input a filename and filles the an int array with the bits of the inputs.
	* For two party it should be called for each party seperatly.
	*/
	int * readInputsFromFile(char* fileName);

	
	/**
	 * Translates the garbled output usually obtained from the compute function into a meaningful(i.e. 0-1) output.
	 *
	 * outputKeys : An array that contains a single garbled value for each output wire. 
	 * return: An array of chars with values 0/1
	 */
	void translate(block *ouyputKeys, unsigned char* answer);


	/**
     * Returns the translation table of the circuit. 
     * This is necessary since the constructor of the circuit may want to pass the translation table to an other party. 
     * Usually, this will be used when the other party (not the constructor of the circuit) creates a circuit, sets the garbled tables 
     * and needs the translation table as well to complete the computation of the circuit.
     * returns : the translation table of the circuit..
	 */
	std::vector<byte> getTranslationTable() { return translationTable; };

	/**
	 * Sets the translation table of the circuit. 
	 * This is necessary when the garbled tables were set and we would like to compute the circuit later on. 
	 * translationTable : This value should match the garbled tables of the circuit.
	 */
	void setTranslationTable(std::vector<unsigned char> translationTable);
	
	/**
	 * The garbled tables are stored in the circuit for all the gates. This method returns the garbled tables which is a GarbledTable array 
	 * equivalent to the number of the garbled gates.
	 * This function is useful if we would like to pass garbled circuits built on different machines. 
	 * This is a compact way to define a circuit, that is, two garbled circuit with the same
	 * basic boolean circuit structure only differ in the garbled tables and the translation table. 
	 * Thus we can hold one circuit and only replace the garbled tables and translation table and get a new garbled circuit.
	 * The advantage is that the size of the tables only, is much smaller than all the information stored in the circuit .
	 * (gates and other member variables). The size becomes important when sending large circuits. 
	 * 
	 * get/setGarbledTable() are used to retrieve/set the garbled tables. 
	 *
	 */
	block* getGarbledTables() { return garbledTables;};
	void setGarbledTables(block* garbledTables);

	/**
	* Checks if two blocks have the same value.
	*/
	bool equalBlocks(block a, block b);


	/**
	* Get function for class members that may be needed by users of the class, rather than a derived class.
	*/
	int *getNumOfInputsForEachParty();
	std::vector<int> getOutputIndices() { return outputIndices;};
	int getNumberOfOutputs() {return numberOfOutputs;};
	int getNumberOfInputs() { return numberOfInputs;};
	int getNumberOfInputs(int partyNumber) { return numOfInputsForEachParty[partyNumber - 1]; };
	std::vector<int> getInputIndices() {return inputIndices;};
	int getNumberOfParties() { return numberOfParties;};
	int getNumberOfGates() { return numberOfGates;};
	int getNumOfXorGates() { return numOfXorGates;};
	int getNumOfNotGates() { return numOfNotGates; };
	int getLastWireIndex() const { return lastWireIndex; };
	bool getIsFreeXor() const { return isFreeXor; };
	virtual int getGarbledTableSize() = 0;
	std::vector<int> getInputWireIndices(int partyNumber);


	protected:

		virtual void createCircuitMemory(const char* fileName, bool isNonXorOutputsRequired) = 0;

		/**
		* turns the string of the truth table that was taken as a decimal number into a number between 0 and 15 which represents the truth table
		* 0 means the truth table of 0000 and 8 means 1000 and so on. The functions returns the decimal representation of the thruth table.
		*/
		int binaryTodecimal(int n);

		/**
		* returns the signal bit if a block (128 bit). This bit the 8'th bit of the 128 bits
		*/
		unsigned char getSignalBitOf(block x) {return *((unsigned char *) (&x)) & 1;};


		//unsigned char getSignalBitOf(block x) { return _mm_extract_epi16(x,  0) % 2; };
		/**
		* This is a simple function that returns the results of 2^p where p=0,1,2,3. Pow of c++ is not used since it uses double casted to int 
		* and this is time consuming. Since we only have 4 options and efficiency is important we use this naive function. Using shifts is also 
		* a little bit slower.
		*/
		int integerPow(int p);

		/*
		* This functions gets a truth tables represented as a decimal number between 0-15 and returns the result of row i,j.
		*/
		int getRowTruthTableResult(int i, int j, unsigned char truthTable);

		/*
		* This function does the same as the above function getRowTruthTableResult. The difference is that it uses shifts.
		*/
		int getRowTruthTableResultShifts(int rowNumber, unsigned char truthTable){ return (truthTable & (1 << (3 - rowNumber))) >> (3 - rowNumber); };

		/*
		*
		*Sets the signal of wire1 to be the complement of wire0.
		*/
		void setSignalBit(block *wire0, block *wire1){ *((unsigned char *)(wire1)) = *((unsigned char *)(wire0)) ^ 1; };
		

		private:

		/*
		* This method generates both keys for each wire. Then, creates the garbled table according to those values.
		* It is a virtual function since each derived class generates the garbled table differently.
		* The keys for each wire are not saved. The input keys and the output keys that were created are returned to the
		* user. The user usually saves these value for later use. The user also gets the generated translation table, which is
		* the signal bits of the output wires.
		*
		* emptyBothInputKeys : An empty block array that will be filled with both input keys generated in garble.
		* emptyBothOutputKeys : An empty block array that will be filled with both output keys generated in garble.
		* emptyTranslationTable : An empty int array that will be filled with 0/1 signal bits that we chosen in random in this function.
		*/
		virtual void garble(block * emptyBothInputKeys, block * emptyBothOutputKeys, std::vector<unsigned char> & emptyTranslationTable, block seed) = 0;
		
};
